package org.hydev.mcpm.server.spiget

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.ObjectMapper
import org.hydev.mcpm.client.models.Database
import org.hydev.mcpm.client.models.PluginModel
import org.hydev.mcpm.client.models.PluginVersion
import org.hydev.mcpm.client.models.PluginYml
import org.hydev.mcpm.client.models.PluginYml.InvalidPluginMetaStructure
import org.hydev.mcpm.server.SpigetCrawler
import org.hydev.mcpm.utils.HashUtils
import org.hydev.mcpm.utils.err
import org.yaml.snakeyaml.error.MarkedYAMLException
import java.io.File
import java.io.IOException
import java.nio.file.Files
import java.util.*

/**
 * Responsible for statically generating database "index" files for mcpm.
 * Used for searches, etc. To create a database use the createDatabase method
 * with a path to the .mcpm/pkgs/spiget directory generated previously by SpigetCrawler.
 */
object CreateDatabase
{
    const val packageStore = ".mcpm"
    private val resources = SpigetCrawler(File(packageStore)).crawlAllResources(false)
    private val idMap = resources.associateBy { it.id }

    /**
     * Main method generates a database in the mcpm directory.
     *
     * @param args Arguments are ignored.
     */
    @JvmStatic
    fun main(args: Array<String>)
    {
        writeDatabase(
            File(packageStore, "pkgs/spiget"),
            File(packageStore, "db"),
            File(packageStore, "db.hash"),
            File(packageStore, "db.timestamp")
        )
    }

    /**
     * Iterates through the crawlerDirectory and assembles and writes a database object to databaseFile.
     *
     * @param crawlerDirectory Path to the .mcpm/pkgs/spiget directory generated by SpigetCrawler.
     * @param dbFile Path to the db.json file that will be written to.
     */
    fun writeDatabase(crawlerDirectory: File, dbFile: File?, hashFile: File?, timeFile: File?)
    {
        val database = createDatabase(crawlerDirectory) ?: return
        try
        {
            ObjectMapper().writeValue(dbFile, database)
            if (hashFile != null)
            {
                try
                {
                    val hash = HashUtils().hash(dbFile)
                    Files.writeString(hashFile.toPath(), hash)
                } 
                catch (e: IOException)
                {
                    err("Failed to write database hash file.")
                }
            }
            if (timeFile != null)
            {
                try
                {
                    val timestamp = System.currentTimeMillis() / 1000L
                    Files.writeString(timeFile.toPath(), timestamp.toString())
                } 
                catch (e: IOException)
                {
                    err("Failed to write database timestamp file.")
                }
            }
        } 
        catch (e: IOException)
        {
            e.printStackTrace()
            err("Failed to write database file.")
        } 
        catch (e: Exception)
        {
            e.printStackTrace()
            err("Failure in DB creation.")
        }
    }

    /**
     * Returns a Database object created from the contents of the crawler directory.
     *
     * @param crawlerDirectory The directory generated by SpigetCrawler that contains package info.
     * @return A database object containing information about the valid plugins.
     */
    fun createDatabase(crawlerDirectory: File): Database?
    {
        val files = crawlerDirectory.listFiles() ?: run {
            err("Missing contents of directory")
            return null
        }

        val plugins = Arrays.stream(files).parallel()
            .map { createPluginModel(it) }
            .filter { it != null }
            .toList()
        // val plugins = files.mapNotNull { createPluginModel(it) }
        return Database(plugins)
    }

    private fun createPluginModel(directory: File): PluginModel?
    {
        try
        {
            val id = directory.name.toLong()
            val versionFiles = directory.listFiles() ?: run {
                err("$id: Missing version directory content")
                return null
            }

            val versions = versionFiles.mapNotNull { createPluginVersion(id, it) }
            if (versions.isEmpty()) {
                err("$id: No version present")
                return null
            }

            return PluginModel(id, idMap[id]?.downloads ?: 0, versions)
        }
        catch (e: NumberFormatException)
        {
            // We don't care, let's keep going.
            e.printStackTrace()
        }
        return null
    }

    private fun createPluginVersion(pluginId: Long, versionDir: File): PluginVersion?
    {
        val metaFile = File(versionDir, "plugin.yml")
        val jarFile = File(versionDir, "release.jar")
        try
        {
            if (!metaFile.isFile)
            {
                err("Missing plugin.yml file for plugin id $pluginId")
                return null
            }
            if (!jarFile.isFile)
            {
                err("Missing release.jar file for plugin id $pluginId")
                return null
            }
            val hash = HashUtils().hash(jarFile)
            val meta = PluginYml.fromYml(Files.readString(metaFile.toPath()))
            val versionId = versionDir.name.toLong()
            return PluginVersion(versionId, jarFile.length(), hash, meta)
        }
        catch (e: Exception)
        {
            when (e) {
                is JsonProcessingException, is MarkedYAMLException, is InvalidPluginMetaStructure -> {
                    err("Cannot read plugin.yml for ${metaFile.toPath()}: $e\n")
                }
                is NumberFormatException, is IOException -> {
                    e.printStackTrace()
                }
                else -> throw e
            }
        }
        return null
    }
}
