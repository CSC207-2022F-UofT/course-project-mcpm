package org.hydev.mcpm.server.crawlers.spiget;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.hydev.mcpm.client.models.Database;
import org.hydev.mcpm.client.models.PluginModel;
import org.hydev.mcpm.client.models.PluginVersion;
import org.hydev.mcpm.client.models.PluginYml;
import org.hydev.mcpm.utils.HashUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.yaml.snakeyaml.error.MarkedYAMLException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

/**
 * Responsible for statically generating database "index" files for mcpm.
 * Used for searches, etc. To create a database use the createDatabase method
 * with a path to the .mcpm/pkgs/spiget directory generated previously by SpigetCrawler.
 */
public class CreateDatabase {
    public static final String packageStore = ".mcpm";

    /**
     * Main method generates a database in the mcpm directory.
     *
     * @param args Arguments are ignored.
     */
    public static void main(String[] args) {
        writeDatabase(
            new File(packageStore, "pkgs/spiget"),
            new File(packageStore, "db"),
            new File(packageStore, "db.hash"),
            new File(packageStore, "db.timestamp")
        );
    }

    /**
     * Iterates through the crawlerDirectory and assembles and writes a database object to databaseFile.
     *
     * @param crawlerDirectory Path to the .mcpm/pkgs/spiget directory generated by SpigetCrawler.
     * @param databaseFile Path to the db.json file that will be written to.
     */
    public static void writeDatabase(File crawlerDirectory,
                                     File databaseFile,
                                     @Nullable File versionFile,
                                     @Nullable File timestampFile) {
        Database database = createDatabase(crawlerDirectory);

        if (database == null)
            return;

        try {
            new ObjectMapper().writeValue(databaseFile, database);

            if (versionFile != null) {
                try {
                    var hash = new HashUtils().hash(databaseFile);

                    Files.writeString(versionFile.toPath(), hash);
                } catch (NoSuchAlgorithmException | IOException e) {
                    System.err.println("Failed to write database hash file.");
                }
            }

            if (timestampFile != null) {
                try {
                    var timestamp = System.currentTimeMillis() / 1000L;

                    Files.writeString(timestampFile.toPath(), String.valueOf(timestamp));
                } catch (IOException e) {
                    System.err.println("Failed to write database timestamp file.");
                }
            }
        } catch (IOException e) {
            e.printStackTrace();

            System.err.println("Failed to write database file.");
        } catch (Exception e) {
            e.printStackTrace();

            System.err.println("Failure in DB creation.");
        }
    }

    /**
     * Returns a Database object created from the contents of the crawler directory.
     *
     * @param crawlerDirectory The directory generated by SpigetCrawler that contains package info.
     * @return A database object containing information about the valid plugins.
     */
    @Nullable
    public static Database createDatabase(File crawlerDirectory) {
        var files = crawlerDirectory.listFiles();

        if (files == null) {
            System.err.println("Missing contents of directory");

            return null;
        }

        List<PluginModel> plugins = Arrays.stream(files).parallel()
            .map(CreateDatabase::createPluginModel)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .toList();

        return new Database(plugins);
    }

    @NotNull
    private static Optional<PluginModel> createPluginModel(File directory) {
        try {
            var id = Long.parseLong(directory.getName());
            var versionFiles = directory.listFiles();

            if (versionFiles == null) {
                System.err.println("Missing version directory content for plugin id " + id);

                return Optional.empty();
            }

            List<PluginVersion> versions = Arrays.stream(versionFiles)
                .map(versionDir -> createPluginVersion(id, versionDir))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .toList();

            return Optional.of(new PluginModel(id, versions));
        } catch (NumberFormatException e) {
            e.printStackTrace();

            // We don't care, let's keep going.
            return Optional.empty();
        }
    }

    @NotNull
    private static Optional<PluginVersion> createPluginVersion(long pluginId, File versionDir) {
        var metaFile = new File(versionDir, "plugin.yml");
        var jarFile = new File(versionDir, "release.jar");

        try {
            if (!metaFile.isFile()) {
                System.err.println("Missing plugin.yml file for plugin id " + pluginId);
                return Optional.empty();
            }

            if (!jarFile.isFile()) {
                System.err.println("Missing release.jar file for plugin id " + pluginId);
                return Optional.empty();
            }

            String hash = new HashUtils().hash(jarFile);

            var meta = PluginYml.fromYml(Files.readString(metaFile.toPath()));

            var versionId = Long.parseLong(versionDir.getName());

            return Optional.of(new PluginVersion(versionId, jarFile.length(), hash, meta));
        } catch (JsonProcessingException | MarkedYAMLException | PluginYml.InvalidPluginMetaStructure e) {
            System.err.printf("Cannot read plugin.yml for %s: %s\n", metaFile.toPath(), e);

            return Optional.empty();
        } catch (NumberFormatException | NoSuchAlgorithmException | IOException e) {
            e.printStackTrace();

            return Optional.empty();
        }
    }
}
